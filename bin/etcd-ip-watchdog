#!/usr/bin/env ruby

require 'ipaddr'
require 'timeout'
require 'socket'
require 'net/ping'
require 'yaml'
require 'json'
require 'etcd'
require 'time'

### EXTENDS
# extend Hash with :deep_merge method
class Hash
  def deep_merge(second)
    merger = proc { |key, v1, v2| Hash === v1 && Hash === v2 ? v1.merge(v2, &merger) : v2 }
    self.merge(second, &merger)
  end
end

# extend Etcd with :members and :healthy? methods
class Etcd::Client
  def members
    members = JSON.parse(api_execute(version_prefix + '/members', :get, timeout: 3).body)['members']
    Hash[members.map{|member| [ member['id'], member.tap { |h| h.delete('id') }]}]
  end

  def healthy?
    JSON.parse(api_execute('/health', :get, timeout: 3).body)['health'] == 'true'
  end

end

### MODULE
module EtcdIPWatchdog
  module Config
    private
    def default_config
      { debug: false,
        parameters: { interface: 'eth0',
                      vip: '192.168.0.168',
                      mask: '255.255.255.0',
                      interval: 1,
                      etcd_endpoint: 'http://127.0.0.1:4001',
                      etcd_interval: 1,
                      etcd_timeout: 5,
                      icmp_count: 2,
                      icmp_interval: 1,
                      arping_count: 1,
                      arping_wait: 1 },
        commands: { arping: `which arping`.chomp,
                    iproute: `which ip`.chomp,
                    arp: `which arp`.chomp } }
    end

    def config
      cfg = default_config
      if File.exist? '/etc/etcd-ip-watchdog.yaml'
        cfg = cfg.deep_merge YAML.load_file('/etc/etcd-ip-watchdog.yaml')
        info '<main> loaded config from /etc/etcd-ip-watchdog.yaml'
      elsif File.exist? './etcd-ip-watchdog.yaml'
        cfg = cfg.deep_merge YAML.load_file('./etcd-ip-watchdog.yaml')
        info '<main> loaded config from ./etcd-ip-watchdog.yaml'
      else
        info '<main> no config file loaded, using defaults'
      end
      cfg
    end
  end

  module Helpers
    def info(message)
      if @config[:debug]
        @semaphore[:log].synchronize do
          $stdout.puts(Time.now.to_s + ' INFO  (TID:' + Thread.current.object_id.to_s + ') ' + message.to_s)
          $stdout.flush
        end
      else
        @semaphore[:log].synchronize do
          $stdout.puts(Time.now.to_s + ' INFO  ' + message.to_s)
          $stdout.flush
        end
      end
    end

    def err(message)
      if @config[:debug]
        @semaphore[:log].synchronize do
          $stdout.puts(Time.now.to_s + ' ERROR (TID:' + Thread.current.object_id.to_s + ') ' + message.to_s)
          $stdout.flush
        end
      else
        @semaphore[:log].synchronize do
          $stdout.puts(Time.now.to_s + ' ERROR ' + message.to_s)
          $stdout.flush
        end
      end
    end

    def debug(message)
      @semaphore[:log].synchronize do
        $stdout.puts(Time.now.to_s + ' DEBUG (TID:' + Thread.current.object_id.to_s + ') ' + message.to_s)
        $stdout.flush
      end if @config[:debug]
    end

    def hostname
      @hostname ||= Socket.gethostname
    end

    def arping
      @config[:commands][:arping]
    end

    def iproute
      @config[:commands][:iproute]
    end

    def arp
      @config[:commands][:arp]
    end

  end

  module Logic
    private
    # is my ETCD the leader?
    # <IMPLEMENTED>
    def leader?(etcd)
      etcd.stats(:self)['id'] == etcd.stats(:self)['leaderInfo']['leader']
    end

    def got_vip?
      cmd = [ iproute,
              'address',
              'show',
              'label',
              "#{@config[:parameters][:interface]}-vip",
              '|',
              'grep',
              '-q',
              "#{@config[:parameters][:interface]}-vip"
            ]
      debug "CMD #{cmd.join(' ')}"
      if system(cmd.join(' '))
        return true
      else
        return false
      end
    end

    # check reachability of VIP by ICMP echo
    # <--- REWORK
    def vip_alive?(icmp)
      (1..@config[:parameters][:icmp_count]).each { return true if icmp.ping }
      return false
    end

    # check whether the IP is registered anywhere
    #
    def vip_dup?
      cmd_arp = [ arp, '-d', @config[:parameters][:vip], '>/dev/null 2>&1' ]
      cmd_arping = [  arping, '-D',
                      '-c', @config[:parameters][:arping_count],
                      '-w', @config[:parameters][:arping_wait],
                      '-I', @config[:parameters][:interface],
                      @config[:parameters][:vip], '>/dev/null 2>&1' ]
      debug "CMD #{cmd_arp.join(' ')}"
      system(cmd_arp.join(' '))
      debug "CMD #{cmd_arping.join(' ')}"
      if system(cmd_arping.join(' '))
        return false
      else
        return true
      end
    end
  end

  module Actions
    private
    # connect to ETCD
    #
    # <--- REWRITE
    #
    def etcd_connect!
      (host, port) = @config[:parameters][:etcd_endpoint].gsub(/^https?:\/\//, '').gsub(/\/$/, '').split(':')
      etcd = Etcd.client(host: host, port: port)
      begin
        versions = JSON.parse(etcd.version)
        info "<etcd> conncted to ETCD at #{@config[:parameters][:etcd_endpoint]}"
        info "<etcd> server version: #{versions['etcdserver']}"
        info "<etcd> cluster version: #{versions['etcdcluster']}"
        info "<etcd> healthy: #{etcd.healthy?}"
        return etcd
      rescue Exception => e
        err "<etcd> couldn't connect to etcd at #{host}:#{port}"
        err "<etcd> #{e.message}"
        @exit = true
      end
    end

    # add or remove VIP on interface
    # <IMPLEMENTED>
    def vip_handle!(leader)
      ip = IPAddr.new(@config[:parameters][:vip])
      mask = @config[:parameters][:mask]
      cmd = [ iproute,
              'address',
              '',
              "#{ip}/#{mask}",
              'dev',
              @config[:parameters][:interface],
              'label',
              @config[:parameters][:interface] + '-vip',
              '>/dev/null 2>&1'
            ]
      case leader
      when true
        cmd[2] = 'add'
      when false
        cmd[2] = 'delete'
      end
      debug "CMD #{cmd.join(' ')}"
      if system(cmd.join(' '))
        info "IP '#{cmd[2]}' operation done"
      else
        err "IP '#{cmd[2]}' operation failed"
      end
    end

    # send gratuitous ARP to the network
    # <IMPLEMENTED>
    def vip_update_arp!
      cmd = [ arping, '-U',
              '-c', @config[:parameters][:arping_count],
              '-I', @config[:parameters][:interface],
              @config[:parameters][:vip], '>/dev/null 2>&1' ]
      debug "CMD #{cmd.join(' ')}"
      if system(cmd.join(' '))
        info 'gratuitous ARP packet sent'
        return true
      else
        err 'gratuitous ARP packet failed to send'
        return false
      end
    end
  end

  class App
    include EtcdIPWatchdog::Config
    include EtcdIPWatchdog::Helpers
    include EtcdIPWatchdog::Logic
    include EtcdIPWatchdog::Actions

    def initialize
      @semaphore = {
        log: Mutex.new,
        etcd: Mutex.new,
        icmp: Mutex.new
      }
      @config = { debug: false }
      @config = config
      @exit = false
    end

    def run
      # handle various signals
      @exit_sigs = ['INT', 'TERM']
      @exit_sigs.each { |sig| Signal.trap(sig) { @exit = true } }
      Signal.trap('USR1') { @config[:debug] = false }
      Signal.trap('USR2') { @config[:debug] = true }
      Signal.trap('HUP') { @config = config }
      if RUBY_VERSION >= '2.1'
        Process.setproctitle('etcd-vip-watchdog')
      else
        $0 = 'etcd-vip-watchdog'
      end
      Process.setpriority(Process::PRIO_PROCESS, 0, -20)
      # Process.daemon
      @thread = {
        icmp: thread_icmp,
        etcd: thread_etcd
      }
      @status_etcd = false
      @status_icmp = false
      @thread.each_value(&:run)
      sleep 5
      first_cycle = true
      while !@exit do
        status_etcd = status_icmp = false # FIXME: introduce CVs...
        @semaphore[:icmp].synchronize { status_icmp = @status_icmp }
        @semaphore[:etcd].synchronize { status_etcd = @status_etcd }
        if status_etcd
          if got_vip?
            debug '<main> i am the leader with VIP, that is OK'
          else
            info '<main> i am the leader without VIP, checking whether it is free'
            if status_icmp
              info '<main> VIP is still up! (ICMP)'
              # FIXME: notify by sensu client socket
            else
              info '<main> VIP is unreachable by ICMP, checking for duplicates on L2'
              if vip_dup?
                info '<main> VIP is still assigned! (ARP)'
                # FIXME: notify by sensu client socket
              else
                info '<main> VIP is free, assigning'
                vip_handle! status_etcd
                info '<main> updating other hosts about change'
                vip_update_arp!
              end
            end
          end
        else
          if got_vip?
            info '<main> i got VIP and should not, removing'
            vip_handle! status_etcd
            info '<main> updating other hosts about change'
            vip_update_arp!
          else
            debug '<main> i am not a leader and i do not have the VIP, that is OK'
          end
        end
        sleep @config[:parameters][:interval]
        if first_cycle
          @semaphore[:icmp].synchronize { status_icmp = @status_icmp }
          @semaphore[:etcd].synchronize { status_etcd = @status_etcd }
          info "<main> i #{status_etcd ? 'AM' : 'am NOT'} the leader"
          info "<main> i #{got_vip? ? 'DO' : 'do NOT'} have the VIP"
          info "<main> i #{status_icmp ? 'CAN' : 'CANNOT'} see the VIP"
        end
        first_cycle = false
      end
      info '<main> terminated!'
      if got_vip?
        info '<main> removing VIP'
        vip_handle! false
        vip_update_arp!
      end
      info '<main> stopping threads...'
      @thread.each_value(&:join)
      info '<main> exiting...'
      exit 0
    end

    def thread_icmp
      Thread.new do
        debug '<icmp> starting thread...'
        icmp = Net::Ping::ICMP.new(@config[:parameters][:vip])
        while !@exit do
          debug '<icmp> checking state by ping'
          status = vip_alive? icmp
          @semaphore[:icmp].synchronize { @status_icmp = status }
          debug "<icmp> VIP is #{status ? 'alive' : 'down' }"
          sleep @config[:parameters][:icmp_interval]
        end
        info '<icmp> ending thread...'
      end
    end

    def thread_etcd
      Thread.new do
        debug '<etcd> starting thread...'
        etcd = etcd_connect!
        while !@exit do
          debug '<etcd> checking etcd state'
          status = leader? etcd
          @semaphore[:etcd].synchronize { @status_etcd = status }
          debug "<etcd> i am #{status ? 'the leader' : 'not a leader' }"
          sleep @config[:parameters][:etcd_interval]
        end
        info '<etcd> ending thread...'
      end
    end
  end
end

app = EtcdIPWatchdog::App.new
app.run
