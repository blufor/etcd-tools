#!/usr/bin/env ruby

require 'ipaddr'
require 'timeout'
require 'socket'
require 'net/ping'
require 'yaml'
require 'json'
require 'etcd'
require 'time'

### EXTENDS ####

class Hash
  def deep_merge(second)
    merger = proc { |key, v1, v2| Hash === v1 && Hash === v2 ? v1.merge(v2, &merger) : v2 }
    self.merge(second, &merger)
  end
end

# extend ETCD lib with :members list
class Etcd::Client
  def members
    members = JSON.parse(api_execute(version_prefix + '/members', :get, timeout: 3).body)['members']
    Hash[members.map{|member| [ member['id'], member.tap { |h| h.delete('id') }]}]
  end

  def healthy?
    JSON.parse(api_execute('/health', :get, timeout: 3).body)['health'] == 'true'
  end

end

### MAIN CLASS ###

class EtcdIPWatchdog

  def initialize
    # default config variables
    @config = {
      debug: false,
      parameters: {
        etcd_endpoint: 'http://127.0.0.1:4001',
        interface: 'eth0',
        vip: '192.168.0.168',
        mask: '255.255.255.0',
        icmp_count: 3,
        arping_count: 1,
        arping_wait: 2
      },
      commands: {
        arping: `which arping`.chomp,
        iproute: `which ip`.chomp,
        arp: `which arp`.chomp
      }
    }

    # read config file
    if File.exists? '/etc/etcd-ip-watchdog.yaml'
      @config = @config.deep_merge YAML.load_file('/etc/etcd-ip-watchdog.yaml')
      info 'loaded config from /etc/etcd-ip-watchdog.yaml'
    elsif File.exists? './etcd-ip-watchdog.yaml'
      @config = @config.deep_merge YAML.load_file('./etcd-ip-watchdog.yaml')
      info 'loaded config from ./etcd-ip-watchdog.yaml'
    else
      info 'no config file loaded, using defaults'
    end

    # connect to ETCD
    @etcd = etcd_connect

  end

  def run
    debug "VIP alive? #{self.vip_alive?}"
    debug "VIP duplicate? #{self.vip_dup?}"
    debug "ETCD leader? #{self.leader?}"
    debug "#{self.vip_handle! self.leader?}"
    debug "#{self.vip_update_arp!}"
  end

  # def run_setter
  #   Thread.new do
  #     loop do
  #       # TODO
  #     end
  #   end
  # end
  #
  # def run_pinger
  #   Thread.new do
  #     loop do
  #       # TODO
  #     end
  #   end
  # end
  #
  # def run_watcher
  #   Thread.new do
  #     loop do
  #       # TODO
  #     end
  #   end
  # end

  def arping
    @config[:commands][:arping]
  end

  def iproute
    @config[:commands][:iproute]
  end

  def arp
    @config[:commands][:arp]
  end

  def hostname
    @hostname ||= Socket.gethostname
  end

  def info message
    $stdout.puts(Time.now.to_s + ' INFO:  [' + caller.reverse.last.sub(/^.*\`([<>a-zA-Z0-9_\ \?\!]+)\'$/, '\\1').to_s + ']: ' + message.to_s)
  end

  def err message
    $stdout.puts(Time.now.to_s + ' ERROR: [' + caller.reverse.last.sub(/^.*\`([<>a-zA-Z0-9_\ \?\!]+)\'$/, '\\1').to_s + ']: ' + message.to_s)
  end

  def debug message
    $stderr.puts(Time.now.to_s + ' DEBUG: [' + caller.reverse.map{ |func| func.sub(/^.*\`([<>a-zA-Z0-9_\ \?\!]+)\'$/, '\\1').to_s }.join('::') + ']: ' + message.to_s) if @config[:debug]
  end

  def etcd_connect
    (host, port) = @config[:parameters][:etcd_endpoint].gsub(/^https?:\/\//, '').gsub(/\/$/, '').split(':')
    etcd = Etcd.client(host: host, port: port)
    begin
      versions = JSON.parse(etcd.version)
      info "conncted to ETCD at #{@config[:parameters][:etcd_endpoint]}"
      info "server version: #{versions['etcdserver']}"
      info "cluster version: #{versions['etcdcluster']}"
      info "healthy: #{etcd.healthy?}"
      return etcd
    rescue Exception => e
      err "couldn't connect to etcd at #{host}:#{port}"
      err e.message
      exit! 1
    end
  end

  # watch the defined path for changes
  #
  def etcd_watch path
    @etcd.watch
  end

  # is my ETCD the leader?
  # <IMPLEMENTED>
  def leader?
    @etcd.stats(:self)['id'] == @etcd.stats(:self)['leaderInfo']['leader']
  end


  # add or remove VIP on interface
  # <IMPLEMENTED>
  def vip_handle! (leader)
    ip = IPAddr.new(@config[:parameters][:vip])
    mask = @config[:parameters][:mask]
    cmd = [ self.iproute,
            'address',
            '',
            "#{ip}/#{mask}",
            'dev',
            @config[:parameters][:interface],
            'label',
            @config[:parameters][:interface] + '-vip',
            '>/dev/null 2>&1'
          ]
    case leader
    when true
      cmd[2] = 'add'
    when false
      cmd[2] = 'delete'
    end
    debug "running: #{cmd.join(' ')}"
    if system(cmd.join(' '))
      info "IP '#{cmd[2]}' operation done"
    else
      err "IP '#{cmd[2]}' operation failed"
    end
  end

  # check reachability of VIP by ICMP echo
  #
  def vip_alive?
    return @alive ||= false
    icmp = Net::Ping::ICMP.new(@config[:parameters][:vip])
    (1..@config[:parameters][:icmp_count]).each do
      ( @alive = true; return @alive ) if icmp.ping
    end
    return @alive
  end

  # check whether the IP is registered anywhere
  #
  def vip_dup?
    cmd_arp = [ self.arp, '-d', @config[:parameters][:vip] ]
    cmd_arping = [  self.arping, '-D',
                    '-c', @config[:parameters][:arping_count],
                    '-w', @config[:parameters][:arping_wait],
                    '-I', @config[:parameters][:interface],
                    @config[:parameters][:vip], '>/dev/null 2>&1' ]
    debug "running: #{cmd_arp.join(' ')}"
    system(*cmd_arp)
    debug "running: #{cmd_arping.join(' ')}"
    if system(cmd_arping.join(' '))
      info 'desired VIP is unallocated'
      return false
    else
      err 'desired VIP is still allocated, doing nothing'
      return true
    end
  end

  # send gratuitous ARP to the network
  #
  def vip_update_arp!
    cmd = [ self.arping, '-U',
            '-c', @config[:parameters][:arping_count],
            '-I', @config[:parameters][:interface],
            @config[:parameters][:vip], '>/dev/null 2>&1' ]
    debug "running: #{cmd.join(' ')}"
    if system(cmd.join(' '))
      info 'gratuitous ARP packet sent'
      return true
    else
      err 'gratuitous ARP packet failed to send'
      return false
    end
  end

end

EtcdIPWatchdog.new.run
