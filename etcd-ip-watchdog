#!/usr/bin/env ruby

require 'ipaddr'
require 'timeout'
require 'socket'
require 'net/ping'
require 'yaml'
require 'json'
require 'etcd'

### EXTENDS ####

class Hash
  def deep_merge(second)
    merger = proc { |key, v1, v2| Hash === v1 && Hash === v2 ? v1.merge(v2, &merger) : v2 }
    self.merge(second, &merger)
  end
end

# extend ETCD lib with :members list
class Etcd::Client
  def members
    members = JSON.parse(api_execute(version_prefix + '/members', :get, timeout: 3).body)['members']
    Hash[members.map{|member| [ member['id'], member.tap { |h| h.delete('id') }]}]
  end

  def healthy?
    JSON.parse(api_execute('/health', :get, timeout: 3).body)['health'] == 'true'
  end

end

### MAIN CLASS ###

class EtcdIPWatchdog

  def initialize
    # default config variables
    @config = {
      parameters: {
        etcd_endpoint: 'http://127.0.0.1:4001',
        interface: 'eth0',
        vip: '192.168.0.168',
        mask: '255.255.255.0',
        icmp_count: 3,
        arping_count: 1,
        arping_wait: 2
      },
      commands: {
        arping: `which arping`.chomp,
        iproute: `which ip`.chomp,
        arp: `which arp`.chomp
      }
    }

    # read config file
    begin
      @config = @config.deep_merge YAML.load_file('/etc/etcd-ip-watchdog.yaml')
      log 'loaded config from /etc/etcd-ip-watchdog.yaml'
    rescue
      @config = @config.deep_merge YAML.load_file('./etcd-ip-watchdog.yaml')
      log 'loaded config from ./etcd-ip-watchdog.yaml'
    rescue
      log 'no config file found, using defaults'
    end

    # connect to ETCD
    @etcd = etcd_connect

    if @etcd.healthy?
      log "ETCD cluster status: healthy"
    else
      log "ETCD cluster status: sick"
    end

    if leader?
      log "ETCD member state: leader"
    else
      log "ETCD member state: follower"
    end
  end

  # def run_setter
  #   Thread.new do
  #     loop do
  #       # TODO
  #     end
  #   end
  # end
  #
  # def run_pinger
  #   Thread.new do
  #     loop do
  #       # TODO
  #     end
  #   end
  # end
  #
  # def run_watcher
  #   Thread.new do
  #     loop do
  #       # TODO
  #     end
  #   end
  # end

  def arping
    @config[:commands][:arping]
  end

  def iproute
    @config[:commands][:iproute]
  end

  def arp
    @config[:commands][:arp]
  end

  def hostname
    @hostname ||= Socket.gethostname
  end

  def log message
    $stdout.puts '[' + caller.reverse.drop(2).map{ |func| func.sub(/^.*\`([<>a-zA-Z0-9_\ ]+)\'$/, '\\1').to_s }.join('::') + ']: ' + message
  end

  def err message
    $stderr.puts caller.last.to_s + ": " + message
  end

  def etcd_connect
    (host, port) = @config[:parameters][:etcd_endpoint].gsub(/^https?:\/\//, '').gsub(/\/$/, '').split(':')
    etcd = Etcd.client(host: host, port: port)
    begin
      versions = JSON.parse(etcd.version)
      log "conncted to ETCD at #{@config[:parameters][:etcd_endpoint]}"
      log "server version: #{versions['etcdserver']}"
      log "cluster version: #{versions['etcdcluster']}"
      return etcd
    rescue Exception => e
      err "E: couldn't connect to etcd at #{host}:#{port}"
      err e.message
      exit! 1
    end
  end

  # watch the defined path for changes
  #
  def etcd_watch path
    @etcd.watch
  end

  # is my ETCD the leader?
  # <IMPLEMENTED>
  def leader?
    @etcd.stats(:self)['id'] == @etcd.stats(:self)['leaderInfo']['leader']
  end


  # add or remove VIP on interface
  #
  def vip_handle! (action)
    cmd = [ self.iproute,
            'address',
            '',
            @config[:parameters][:vip],
            'dev',
            @config[:parameters][:interface],
            'label',
            @config[:parameters][:interface] + '-vip'
          ]

    case action
    when :leader
      cmd[2] = 'add'
    when :follower
      cmd[2] = 'delete'
    end

    system(*cmd)
  end

  # check reachability of VIP by ICMP echo
  #
  def vip_alive?
    icmp = Net::Ping::ICMP.new(@config[:parameters][:vip])
    (1..@config[:parameters][:icmp_count]).each do
      icmp.ping and return true
    end
    return false
  end

  # check whether the IP is registered anywhere
  #
  def vip_dup?
    log system(self.arp, '-d', @config[:parameters][:vip])
    log system(self.arping, '-D', '-c1', '-w5', '-I', @config[:parameters][:interface], @config[:parameters][:vip]) ? false : true
  end

  # send gratuitous ARP to the network
  #
  def vip_update!
    system( self.arping, '-U', '-c3', '-I', @config[:parameters][:interface], @config[:parameters][:vip] )
  end

end

app = EtcdIPWatchdog.new
